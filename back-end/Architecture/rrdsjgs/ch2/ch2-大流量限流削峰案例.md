

# 第2章 大流量限流/消峰案例

* 大流量和高并发的问题
  * 连接资源耗尽
  * 分布式缓存容器撑爆
  * 数据库吞吐量降低
* 办法
  * 扩容
  * 动静分离
  * 缓存
  * 服务降级
  * 限流

## 2.1 分布式系统为什么需要进行流量管制

* 限流
  * 流量管制让系统的负载处于一个比较均衡的水位
* 办法
  * CDN：静态数据缓存在CDN上
  * 读服务：读请求尽量在缓存命中
  * 写服务：交易系统进行限流处理，避免给数据库带来较大的负载压力
  * 数据库：读写分离

## 2.2 限流的具体方案

### 2.2.1 常见的限流算法

* 池化资源技术
  * 数据库连接池、线程池、对象池
  * 池化资源技术通过计数器算法来控制全局的总并发数
* 令牌桶算法（Token Bucket）
  * 限制流量的平均流量的**平均流入速率**，并允许出现突发流量
  * 每秒r个令牌放入桶
  * 桶的容量固定不变
  * n个字节的请求消耗n个令牌后，再发送数据包
  * 可用令牌小于n，该数据包将被抛弃或缓存（限流）
* 漏桶算法（Leaky Bucket）
  * 限制流量流出速率，流出速率固定不变，不允许出现突发流量
  * 匀速流入
  * 桶满则弃（超过桶容量，新请求执行限流）
  * 匀速流出
  
### 2.2.2 使用Google的Guava实现平均速率限流

* Guava
  * 封装了集合框架和Cache等特性
  * 本地缓存框架EhCache或Guava Cache
  * Guava限流
* RateLimiter
  * Guava中RateLimiter提供令牌桶算法的实现
  * tryAcquire可以模拟直接等待或短暂等待的情况

### 2.2.3 使用Nginx实现接入层限流

* Tengine
  * limit_zone：定义每个IP的session空间大小
  * limit_req_zone：定义每个IP每秒允许发起的请求数
  * limit_conn：定义每个IP能够发起的并连接数
  * limit_req：缓存还没来得及处理的请求

### 2.2.4 使用计数器算法实现商品抢购限流

* 抢购限流
  * 指定的SKU在单位时间内允许被抢购的次数
  * 超过阈值，则拒绝新的请求，或抢购失败实施排队

## 2.3 基于时间分片的消峰方案

* 削峰
  * 对峰值流量进行分散处理，避免在同一时间段内产生较大的用户流量
  * 活动分时段进行实现削峰
  * 通过答题验证实现削峰

## 2.4 异步调用需求

Java7中Fork/Join框架

### 2.4.1 使用MQ实现系统之间的解耦

* 解耦
  * 消息传递实现异步调用
  * 业务子系统之间可用通过RPC请求实现服务调用
  * 依赖不是必须的，可以用消息传递替代RPC调用