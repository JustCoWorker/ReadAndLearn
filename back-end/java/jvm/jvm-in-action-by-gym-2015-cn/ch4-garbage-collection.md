

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [4 垃圾回收概念与算法](#4-垃圾回收概念与算法)
	* [4.2 清洁工具大PK：讨论常用的垃圾回收算法](#42-清洁工具大pk讨论常用的垃圾回收算法)
		* [4.2.1 引用计数法(Reference Counting)](#421-引用计数法reference-counting)
		* [4.2.2 标记清除法(Mark-Sweep)](#422-标记清除法mark-sweep)
		* [4.2.3 复制算法(Copying)](#423-复制算法copying)
		* [4.2.4 标记压缩法(Mark-Compact)](#424-标记压缩法mark-compact)
		* [4.2.5 分代算法(Generational Collecting)](#425-分代算法generational-collecting)
		* [4.2.6 分区算法（Region）](#426-分区算法region)
	* [4.3 可触及性](#43-可触及性)
		* [4.3.1 对象的复活](#431-对象的复活)
		* [4.3.2 引用和可触及性的强度](#432-引用和可触及性的强度)
		* [4.3.3 软引用-可被回收的引用](#433-软引用-可被回收的引用)
		* [4.3.4 弱引用-发现即回收](#434-弱引用-发现即回收)
		* [4.3.5 虚引用-对象回收跟踪](#435-虚引用-对象回收跟踪)
	* [4.4 垃圾回收时的停顿现象：Stop-The-World案例实战](#44-垃圾回收时的停顿现象stop-the-world案例实战)

<!-- /code_chunk_output -->

---


# 4 垃圾回收概念与算法


## 4.2 清洁工具大PK：讨论常用的垃圾回收算法

### 4.2.1 引用计数法(Reference Counting)

* 引用计数器的实现：
  * 对象A，有任何一个对象引用了A，则A的引用计数器加1；
  * 引用失效时，引用计数器减1；
  * 对象A的引用计数器为0，则对象A不再被使用。
* 引用计数器的问题：
  * 无法处理循环引用；
  * 需要伴随加法操作和减法操作，对系统性能产生影响。
* 循环引用问题：
  * 对象A中含有对象B的引用，对象B中含有对象A的引用；
  * 对象A和对象B的引用计数器都不为0；
  * 系统中不存在第3个对象引用A或B；
  * A和B应该是被回收的垃圾对象，但垃圾对象间互相引用，垃圾回收器无法识别。
* 名词解释：
  * 可达对象：通过根对象进行引用搜索，最终可以达到的对象；
  * 不可达对象：通过根对象进行引用搜索，最终没有被引用到的对象。

### 4.2.2 标记清除法(Mark-Sweep)

* 标记清除算法：
  * 标记阶段：通过根节点，标记所有从根接单开始的可达对象；
  * 清除阶段：清除所有未被标记的对象；
  * 空间碎片：回收后的空间是不连续的。不连续内存空间的工作效率要低于连续的空间。

### 4.2.3 复制算法(Copying)

* 复制算法：
  * 将内存空间分为两块，每次只使用其中一块；
  * 垃圾回收时，将存活对象复制到未使用的内存块中；
  * 清除正在使用的内存块的所有对象，交换两个内存的角色。
* 优点：
  * 垃圾对象较多是需要复制的存活对象少，效率高；
  * 回收后的内存空间没有碎片；
* 缺点：
  * 内存折半

新生代串行垃圾回收器中，使用了复制算法。from和to空间可进行角色互换的空间呢块。

### 4.2.4 标记压缩法(Mark-Compact)

* 标记压缩算法：
  * 从根节点开始，对所有可达对象做标记；
  * 将所有存活对象压缩到内存的一端；
  * 清理边界外所有的空间。
* 优点：
  * 避免碎片的产生；
  * 不需要两块相同的内存空间。

### 4.2.5 分代算法(Generational Collecting)

* 分代算法：
  * 将内存区间根据对象的特点分成几块，每块使用不同的回收算法；
  * 新生代使用复制算法；
  * 老年代使用标记压缩或标记清除算法；
* 卡表：
  * 老年代的某一区域中的所有对象是否持有新生代对象的引用；

### 4.2.6 分区算法（Region）

* 分区算法：
  * 分代算法将按照对象的生命周期长短划分成两个部分；
  * 分区算法将整个堆空间划分成连续的不同小区间；
  * 每个小区间都独立使用，独立回收。

## 4.3 可触及性

* 可触及性：
  * 可触及的：从根节点开始，可以到达这个对象；
  * 可复活的：引用释放，在finalize()函数中复活；
  * 不可触及的：未在finalize()函数中复活；

### 4.3.1 对象的复活

引用外泄，在无意中复活对象。

### 4.3.2 引用和可触及性的强度

* Java 中提供4个级别的引用：强引用、软引用、弱引用和虚引用。
  * java.lang.ref；
  * 强引用是可触及的，不被回收；
  * 软引用、弱引用和虚引用可被回收；
* 强引用
  * 强引用可以直接访问目标对象；
  * 系统不回收强引用指向的对象；
  * 强引用可能导致内存泄露；

### 4.3.3 软引用-可被回收的引用

* 软引用
  * GC未必会回收软引用的对象；
  * 堆空间不足时会回收软引用对象；
  * java.lang.ref.SoftReference；
  * 软引用对象不会引起内存溢出；
  * 当对象由可达变为不可达，软引用对象会进入引用队列ReferenceQueue；

### 4.3.4 弱引用-发现即回收

* 弱引用
  * GC发现弱引用即回收；
  * 软引用、弱引用都适合保存那些可有可无的缓存数据；

### 4.3.5 虚引用-对象回收跟踪

* 虚引用
  * 随时可能被回收；
  * 虚引用必须和引用队列一起使用；
  * 用于跟踪垃圾回收过程；

## 4.4 垃圾回收时的停顿现象：Stop-The-World案例实战

* 停顿Stop-The-World
  * 终止所有线程的执行，不产生新的垃圾；
  * 保证一瞬间的一致性；
  * 有益于垃圾回收器标记垃圾对象；