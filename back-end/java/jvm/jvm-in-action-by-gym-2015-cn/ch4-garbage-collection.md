

<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [4 垃圾回收概念与算法](#4-垃圾回收概念与算法)
	* [4.2 清洁工具大PK：讨论常用的垃圾回收算法](#42-清洁工具大pk讨论常用的垃圾回收算法)
		* [4.2.1 引用计数法(Reference Counting)](#421-引用计数法reference-counting)
		* [4.2.2 标记清除法(Mark-Sweep)](#422-标记清除法mark-sweep)
		* [4.2.3 复制算法(Copying)](#423-复制算法copying)
		* [4.2.4 标记压缩法(Mark-Compact)](#424-标记压缩法mark-compact)
		* [4.2.5 分代算法(Generational Collecting)](#425-分代算法generational-collecting)
		* [4.2.6 分区算法（Region）](#426-分区算法region)
	* [4.3 可触及性](#43-可触及性)

<!-- /code_chunk_output -->

---


# 4 垃圾回收概念与算法


## 4.2 清洁工具大PK：讨论常用的垃圾回收算法

### 4.2.1 引用计数法(Reference Counting)

* 引用计数器的实现：
  * 对象A，有任何一个对象引用了A，则A的引用计数器加1；
  * 引用失效时，引用计数器减1；
  * 对象A的引用计数器为0，则对象A不再被使用。
* 引用计数器的问题：
  * 无法处理循环引用；
  * 需要伴随加法操作和减法操作，对系统性能产生影响。
* 循环引用问题：
  * 对象A中含有对象B的引用，对象B中含有对象A的引用；
  * 对象A和对象B的引用计数器都不为0；
  * 系统中不存在第3个对象引用A或B；
  * A和B应该是被回收的垃圾对象，但垃圾对象间互相引用，垃圾回收器无法识别。
* 名词解释：
  * 可达对象：通过根对象进行引用搜索，最终可以达到的对象；
  * 不可达对象：通过根对象进行引用搜索，最终没有被引用到的对象。

### 4.2.2 标记清除法(Mark-Sweep)

* 标记清除算法：
  * 标记阶段：通过根节点，标记所有从根接单开始的可达对象；
  * 清除阶段：清除所有未被标记的对象；
  * 空间碎片：回收后的空间是不连续的。不连续内存空间的工作效率要低于连续的空间。

### 4.2.3 复制算法(Copying)

* 复制算法：
  * 将内存空间分为两块，每次只使用其中一块；
  * 垃圾回收时，将存活对象复制到未使用的内存块中；
  * 清除正在使用的内存块的所有对象，交换两个内存的角色。
* 优点：
  * 垃圾对象较多是需要复制的存活对象少，效率高；
  * 回收后的内存空间没有碎片；
* 缺点：
  * 内存折半

新生代串行垃圾回收器中，使用了复制算法。from和to空间可进行角色互换的空间呢块。

### 4.2.4 标记压缩法(Mark-Compact)

* 标记压缩算法：
  * 从根节点开始，对所有可达对象做标记；
  * 将所有存活对象压缩到内存的一端；
  * 清理边界外所有的空间。
* 优点：
  * 避免碎片的产生；
  * 不需要两块相同的内存空间。

### 4.2.5 分代算法(Generational Collecting)

* 分代算法：
  * 将内存区间根据对象的特点分成几块，每块使用不同的回收算法；
  * 新生代使用复制算法；
  * 老年代使用标记压缩或标记清除算法；
* 卡表：
  * 老年代的某一区域中的所有对象是否持有新生代对象的引用；

### 4.2.6 分区算法（Region）

* 分区算法：
  * 分代算法将按照对象的生命周期长短划分成两个部分；
  * 分区算法将整个堆空间划分成连续的不同小区间；
  * 每个小区间都独立使用，独立回收。

## 4.3 可触及性

* 可触及性：
  * 可触及的：从根节点开始，可以到达这个对象；
  * 可复活的：引用释放，在finalize()函数中复活；
  * 不可触及的：未在finalize()函数中复活；

