

# 第4章　解决Rabbit相关问题：编码与模式

* 本章要点
  * 面向消息通信来设计应用程序
  * 消息通信模式
  * 发后即忘模式
  * 用RabbitMQ实现RPC
* 问题：解耦请求和操作
  * 将耗时任务从应用程序中移出
  * 整合不同语言
* 解决方案
  * 异步编程解决方案，重写所有代买以至于没有一处是同步的
  * RabbitMQ运行发送请求并在另一处进行处理

## 4.1　解耦风雨路：谁将我们推向消息通信

应用程序和存储之间直接耦合通常就是导致之后代码呗淘汰和取代的原因

### 4.1.1　异步状态思维（分离请求和动作）

通过在应用中紧密耦合的两部分中间使用RabbitMQ，之前每次只能处理一个请求而现在可以持续接收请求

### 4.1.2　提供扩展性：没有负载均衡器的世界

RabbitMQ使用自动轮询（round-robin）行为模式，将请求在处理服务器间平均的分发

### 4.1.3　零成本API ：语言不应成为枷锁

## 4.2 发后即忘模型

* 发后即忘模式的任务
  * 批处理：针对大型数据集合的工作或者转换
  * 通知：对发生事件的描述

### 4.2.1 发送告警

* fanout交换器
  * 好处是Web应用不需要知道告警信息是如何投递到最终接受者的
  * 坏处是每个告警传输者都会得到一份拷贝
* direct
  * 创建是三种严重级别告警：info、warning和critical
  * 允许应用程序为告警消息贴上严重登记的标签，用来作为路由键
* topic交换器
  * 不会受限于每个alert只有一种严重级别
  * 可以为消息贴上`严重级别标记和类型标记`