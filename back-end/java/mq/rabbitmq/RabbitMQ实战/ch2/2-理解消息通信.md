
# 第2章　理解消息通信

* 本章要点
  * 消息通信概念：消费者、生产者和代理
  * AMQP元素：交换机、队列和绑定
  * 虚拟主机
  * 消息持久化
  * 一条消息历经从生产者到消费者的生命周期
* AMQP
  * 存储离线消费者存储消息
  * 根据标签路由消息
  * 消息没有固定的接口，可以直接存储二进制数据
  * AMQP隐去了消息的发送方和接收方
  * 能以一对多广播，也可以一对一的方式路由

## 2.1　消费者和生产者（这可不是经济学课程哦）

* 快餐车模式
  * 客户端和服务器端
* 消息投递服务
  * RabbitMQ在应用程序和服务器之间扮演着路由器的角色
* 生产者
  * 创建消息，然后发布到代理服务器
  * 消息两部分
    * 有效载荷payload
      * 传输的数据
      * 任何内容
    * 标签label
      * 描述有效载荷，RabbitMQ用它来决定谁将获得消息的拷贝
      * 发后即忘fire-and-forget的单向方式
* 消费者
  * 在消息路由过程中，消息的标签并没有随着有效载荷一同传递
* 信道
  * 在应用程序和Rabbit代理服务器之间创建一条TCP连接
  * 应用程序就可以创建一条AMQP信道
  * 信道是建立在“真实的”TCP连接内的虚拟连接
  * 对操作系统来说建立和销毁TCP会话是非常昂贵的开销
  * 在一条TCP连接上创建多少条信道是没有限制的
  * 使用多个信道，线程可以同时共享连接

## 2.2　从底部开始构造：队列

* AMQP消息路由三部分
  * 交换机
  * 队列
  * 绑定：决定消息如何从路由器路由到特定的队列
* 消费者接收消息的两种方式
  * basic.consume：消息到达队列自动接收
  * basic.get：从队列获得单挑消息而不是持续订阅
* 消费者
  * 当Rabbit队列拥有对个消费者时
  * 队列收到的消息将以循环round-robin的方式发送给消费者
  * 每条消息只会发送给一个订阅的消费者
  * 消费者通过确认命令告诉RabbitMQ它已经正确的接收了消息
  * 同时RabbitMQ才能安全的把消息从队列中删除
* 消息未确认的两个选择
  * 把消费者从RabbitMQ服务器断开连接
    * 自动重新入队并发送给另一个消费者
    * 额外增加RabbitMQ的负担
  * basic.reject拒绝消息
    * requeue=true，重新发送消息给下一个订阅的消费者
    * requeue=false，把消息从队列中移除
* 创建队列
  * queue.declare
  * exclusive：队列私有
  * auto-delete：当最后一个消费者取消订阅的时候，队列就会自动移除
  * 声明一个已经存在的队列，声明参数完全匹配现存的队列的话，Rabbit就直接返回
* 队列是AMQP消息通信的基础模块
  * 为消息提供了处所，消息在此等待消费
  * 对负载均衡来说，只需附加消费者，并让RabbitMQ以循环的方式均匀的分配发来的消息
  * 队列是Rabbit中消息的最后的终点

## 2.3　联合起来：交换器和绑定

* 路由键
  * 队列通过路由键（routing key）绑定到交换机
  * 匹配则投递到该队列
  * 不匹配则进入“黑洞”
* 处理投递多个队列的四种类型
  * direct
    * 如果路由键匹配的话，消息就被投递到对应的队列
    * 当声明一个队列时，自动绑定到默认交换器，并以队列名称作为路由键
  * fanout
    * 把消息投递给所有附加在此交换器上的队列
  * topic
    * 将来自不同源头的消息能够到达同一个队列
  * headers
    * 匹配AMQP消息的header而非路由键
* 知识点
  * AMQP架构中最关键的几个组件分别是交换机、队列和绑定
  * 根据绑定规则将队列绑定到交换机上
  * 消息时发布到交换机上的
  * 有三种类型的交换机：direct, fanout和topic
  * 基于消息的路由键和交换器类型，服务器会决定将消息头顶到哪个队列去

## 2.4　多租户模式：虚拟主机和隔离

* vhost
  * 虚拟消息服务器
  * 通过在各个实例间提供逻辑上分离，为不同应用程序安全保密的运行数据
  * 将同一Rabbit的众多客户区分开来，避免队列和交换器的命名冲突
  * 创建一个用户时，用户通常会被指派给至少一个vhost，并只能访问呗指派vhost内的队列、交换器和绑定
  * 这既保证了安全性，又确保了可移植性
* 创建
  * vhost和权限控制无法通过AMQP协议创建的基元（不同于队列，交换器和绑定）
  * ./sbin/rabbitmqctl

## 2.5　我的消息去哪儿了呢？持久化和你的策略

* 持久化消息
  * 重启RabbitMQ，默认情况下，队列、交换器和消息均会消失
  * 队列和交换器的durable属性设置为true
  * 条件
    * 把投递模式选项设置为2（持久）
    * 发送到持久化的交换器
    * 到达持久化的队列
* 消息恢复方式
  * 将消息写入磁盘上的一个持久化日志文件
  * 当发布一条持久性消息到持久交换器上时，Rabbit会在消息提交到日志文件后才发送响应
  * 从持久化队列中消费一条持久化消息后，将这条消息标记为等待垃圾收集
* 持续化消息的性能代价
  * 写入磁盘要比存入内存中慢，减少RabbitMQ每秒可处理的消息总数
  * 持久性消息均匀的分布在各个节点而没有冗余
* 为关键消息使用持久化机制
* AMQP事务
  * 如果事务中的首次发布成功了，那么信道会在事务中完成其他AMQP命令
  * 使用事务会降低消息吞吐量，还会使生产者应用程序产生同步
* 发送方确认模式
  * 信道设置成confirm模式，只能通过重新创建信道来关闭该设置
  * 一旦消息被投递，信道会发送一个发送方确认模式给生产者
  * 异步的、没有消息回滚的概念

## 2.6　把所有内容结合起来：一条消息的一生

* 安装
  * python
  * easy_install, python ez_setup.py
  * easy_install pika
* 发布者任务
  * 连接到RabbitMQ
  * 获取信道
  * 声明交换器
  * 创建消息
  * 发布消息
  * 关闭信道
  * 关闭连接

```py
#声明消息
#交换器名称hello-exchange
#交换器类型direct
#发送非模式的declare命令
#持久化交换器，并且不会自动删除
channel.exchange_declare(exchange="hello-exchange",
                          type="direct",
                          passive=False,
                          durable=True,
                          auto_delete=False)
```

* 消费者任务
  * 连接到RabbitMQ
  * 获得信道
  * 声明交换器
  * 声明队列
  * 把队列和交换器绑定起来
  * 消费消息
  * 关闭信道
  * 关闭连接

新的内容是如何声明队列，并绑定到交换器上，然后开始消费新消息

```py
channel.queue_declare(queue="hello-queue")
channel.queue_bind(queue="hello-queue",
                    exchange="hello-exchange",
                    routing_key="hola")
channel.basic_consume(msg_consumer,
                      queue="hello-queue",
                      consumer_tag="hello-consumer")
```

## 2.7　使用发送方确认模式来确认投递

* 信道
  * 一条信道只能被单个线程使用，确保信道上发布的消息都是连续的
  * 任一信道上发布的第一条消息将获得1，并且信道上接下来的每一条消息的ID都将进步1
  * 同时拥有众多运行的信道，需要为每条信道分别维护一个内部消息ID计数器

```py
#将信道设置成confirm模式，并用confirm_handler作为回调函数
channel.confirm_delivery(callback=confirm_handler)
#当第一次将信道设置为confirm模式时，RabbitMQ会发送一条Confirm.SelectOK类型的确认消息
```