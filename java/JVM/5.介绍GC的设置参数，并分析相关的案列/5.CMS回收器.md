CMS回收器
CMS（Concurrent Mark Sweep）

* 概述
  * 主要适合场景是对响应时间的重要性需求 大于对吞吐量的要求，
  * 能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用
  * CMS是用于对老年代的回收，目标是尽量减少应用的暂停时间，减少full gc发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代
* CMS收集周期
  * CMS并非没有暂停，而是用两次短暂停来替代串行标记整理算法的长暂停
* CMS的步骤
  1. 初始标记（STW独占）CMS-initial-mark
  2. 并发标记CMS-concurrent-mark
  3. 预清理CMS-concurrent-preclean
  4. 重新标记（STW独占）CMS-remark
  5. 并发清除CMS-concurrent-sweep
  6. 并发重置CMS-concurrent-reset
* CMS
  * `并发`是指收集器和应用线程交替执行；
  * `并行`是指应用程序停止，同时由多个线程一起执行GC；
  * CMS（Concurrent Mark Sweep）回收器主要关注与`系统停顿时间`，意为并发标记清除。
  * 基于`标记清除算法`，将会造成内存碎片；
  * `abortable-preclean`，CMS根据之前新生代GC的情况，将`重新标记`的时间放置在一个最不可能和下一次新生代GC重叠的时刻；
  * 当堆内存使用率达到某一阈值时便开始进行回收，以确保应用程序在CMS工作过程中，依然有足够的空间支持应用程序运行；
  * 在CMS执行过程中，已经出现内存不足的情况`concurrent mode failure`，会导致CMS回收失败，虚拟机启动老年代串行收集器进行垃圾回收；
* 参数
  * -XX:-CMSPrecleaningEnabled，不进行预清理；
  * -XX:+UseConcMarkSweepGC，启用CMS回收器；
  * -XX:ParallelGCThreads，GC并行时使用的线程数量。CMS并发线程数默认为(ParallelGCThreads+3)/4
  * -XX:ConcGCThreads或-XX:ParallelCMSThreads，设置并发线程数量；
  * -XX:CMSInitiatingOccupancyFraction，回收阈值，默认为68；
  * -XX:+UseCMSCompactAtFullCollection，CMS垃圾回收后，进行一次内存整理；
  * -XX:CMSFullGCsBeforeCompaction，多少次CMS回收后，进行一次内存压缩；
  * -XX:+CMSClassUnloadingEnabled，CMS回收Perm区；

  ## 参考

  1. 实战JAVA虚拟机.JVM故障诊断与性能优化
  2. https://www.cnblogs.com/ggjucheng/p/3977612.html
  3. https://blog.csdn.net/hqq2023623/article/details/50993165