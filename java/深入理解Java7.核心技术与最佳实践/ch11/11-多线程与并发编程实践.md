

#  第11章 多线程与并发编程实践

* Java多线程三个困难
  * 编写正确的程序很难
  * 很难测试程序是否正确
  * 在程序出现问题时很难调试
* 知识的三个部分
  * 多线程的基础知识，JVM层次
  * 基本线程同步方式，锁机制和Object类中wait、notify和notifyAll
  * java.util.concurrent高层次抽象

##  11.1 多线程

* 进程
  * 资源的组织单位
  * 有独立的地址空间，包含程序内容和数据
  * CPU调度执行的基本单位
  * 有程序计数器、寄存器、堆栈和帧
* 一个程序中主要存在使用CPU和IO操作两类计算
* Java API
  * java.lang.Process和java.lang.ProcessBuilder
  * java.lang.Thread
* 两种创建线程的方式
  * 继承Thread类，并覆写run方法
  * 实现Runnable接口，并在Thread类的构造方法中传入Runnable接口

###  11.1.1 可见性

* 可见性
  * 同一个进程中的各个线程通过共享内存的方式来进行通信
  * 使用共享内存方式在多线程程序中可能造成可见性相关的问题
    * CPU一般采用`多级缓存架构`
      * 在某些时间点上，缓存中的数据与主存中的数据可能是不一样的
    * `代码重排`：编译器在编译时可能会对生成的字节码中的指令顺序进行重新排列，以优化指令的执行顺序

###  11.1.2 java内存模型

* java内存模型
  * 描述了程序中共享变量的关系以及在主存中写入和读取这些变量值的底层细节

##  11.6 java se 7新特性

###  11.6.1 轻量级任务执行框架fork join

* fork/join框架
  * 利用底层平台上的多核CPU和多处理器来进行并行处理
  * fork操作的作用是把一个大的问题划分成若干个较小的问题
  * 每个子问题在计算完成之后，可以得到关于整个问题的部分解
  * join操作把这些部分解收集并组织起来，得到最终的完整解
* 任务处理方式
  * 某个子问题由于等待另外一个子问题的完成而无法继续运行
  * 处理该子问题的线程会主动寻找其他尚未运行的子问题来执行
  * 每个子问题应该避免使用synchronized关键词等方式来同步
* ForkJoinTask
  * fork方法异步启动任务
  * join等待任务完成并返回执行结果
  * RecursiveTask返回结果
  * RecursiveAction不返回
* 任务执行
  * 通过execute, invoke或submit方法直接提交任务
  * 在执行过程中产生的子任务，通过fork方法来运行

###  11.6.2 多阶段线程同步工具

* Phaser实用同步工具
  * 把多个线程协作执行的任务划分成多个阶段phase
  * 每个阶段上都可以有任意个参与者参与
  * 线程可以随时注册并参与到某个阶段的执行中来
  * 一个阶段中所有线程都成功完成后，自动进入下一个阶段
* Phaser类
  * register/bulkRegister动态添加参与者
  * arrive参与者完成任务
  * arrive参与者声明完成取消注册
  * arriveAndAwaitAdvance参与者等待其他参与者完成，并阻塞
  * awaitAdvance/awatiAdvanceInterruptibly等待Phaser对象进入下一个阶段
* onAdvance
  * 某个阶段中的所有参与者都完成任务
  * 可以覆写此方法来添加自定义的处理逻辑
* 树型结构
  * 多个Phaser对象可以组织成树型结构
  * 提供构造方法指定当前对象的父对象

##  11.7 threadlocal类

* ThreadLocal
  * 线程局部变量
  * 不同线程访问一个ThreadLocal类，所访问和修改的是每个线程各自独立的对象
  * 通过ThreadLocal，快速的把一个非线程安全的对象转换成线程安全的对象
  * 创建线程唯一的对象